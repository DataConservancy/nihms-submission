/*
 * Copyright 2018 Johns Hopkins University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.dataconservancy.pass.deposit.assembler.dspace.mets;

import org.apache.commons.io.IOUtils;
import org.apache.commons.io.input.DigestObserver;
import org.apache.commons.io.input.ObservableInputStream;
import org.apache.commons.io.output.NullOutputStream;
import org.dataconservancy.nihms.assembler.PackageStream;
import org.dataconservancy.nihms.assembler.ResourceBuilder;
import org.dataconservancy.nihms.model.DepositFileType;
import org.dataconservancy.nihms.model.DepositSubmission;
import org.dataconservancy.pass.deposit.assembler.shared.DefaultMetadataBuilderFactory;
import org.dataconservancy.pass.deposit.assembler.shared.DefaultResourceBuilderFactory;
import org.dataconservancy.pass.deposit.assembler.shared.ResourceBuilderFactory;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.Resource;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

import static org.dataconservancy.pass.deposit.assembler.dspace.mets.DepositTestUtil.asList;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.DepositTestUtil.composeSubmission;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.DepositTestUtil.fromClasspath;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.DepositTestUtil.packageToClasspath;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.XMLConstants.METS_CHECKSUM;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.XMLConstants.METS_CHECKSUM_TYPE;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.XMLConstants.METS_FILE;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.XMLConstants.METS_FLOCAT;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.XMLConstants.METS_MIMETYPE;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.XMLConstants.METS_NS;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.XMLConstants.METS_SIZE;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.XMLConstants.XLINK_HREF;
import static org.dataconservancy.pass.deposit.assembler.dspace.mets.XMLConstants.XLINK_NS;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Creates a package, then extracts it.  Performs some basic tests on the extracted package.
 *
 * @author Elliot Metsger (emetsger@jhu.edu)
 */
public class DspaceMetsAssemblerIT {

    @Rule
    public TestName testName = new TestName();

    private static final Logger LOG = LoggerFactory.getLogger(DspaceMetsAssemblerIT.class);

    /**
     * The custodial resources that to be packaged up by {@link #setUp()}.  They should be present in the extracted
     * package.
     */
    private List<Resource> custodialResources;

    /**
     * The custodial resources that to be packaged up by {@link #setUp()}, keyed by file name.  They should be present
     * in the extracted package
     */
    private Map<String, Resource> custodialResourcesMap;

    /**
     * The package generated by {@link #setUp()} is extracted to this directory
     */
    private File extractedPackageDir;

    /**
     * The {@link ResourceBuilderFactory} used by the {@link DspaceMetsAssembler} to create {@link
     * PackageStream.Resource}s from the {@link #custodialResources custodial resources}
     */
    private ResourceBuilderFactory rbf;

    /**
     * The mets.xml from the package built and extracted by {@link #setUp()}, parsed into a {@link Document}
     */
    private Document metsDoc;

    /**
     * Mocks a submission, and invokes the assembler to create a package based on the resources under the
     * {@code sample1/} resource path.  Sets the {@link #extractedPackageDir} to the base directory of the newly created
     * and extracted package.
     *
     * @throws Exception
     */
    @Before
    public void setUp() throws Exception {
        DefaultMetadataBuilderFactory mbf = new DefaultMetadataBuilderFactory();
        rbf = new DefaultResourceBuilderFactory();
        DspaceMetsAssembler underTest = new DspaceMetsAssembler(mbf, rbf,
                new DspaceMetadataDomWriter(DocumentBuilderFactory.newInstance()));

        custodialResources = fromClasspath(packageToClasspath(this.getClass()) + "/sample1");

        // Insure we're packaging something
        assertTrue("Refusing to create an empty package!",custodialResources.size() > 0);
        custodialResourcesMap = custodialResources.stream().collect(Collectors.toMap(Resource::getFilename, Function
                .identity()));

        Map<File, DepositFileType> custodialContentWithTypes = new HashMap<>();

        custodialResourcesMap.forEach((fileName, resource) -> {
            if (fileName.endsWith(".doc")) {
                try {
                    custodialContentWithTypes.put(resource.getFile(), DepositFileType.manuscript);
                } catch (IOException e) {
                    throw new RuntimeException(e.getMessage(), e);
                }
            } else {
                try {
                    custodialContentWithTypes.put(resource.getFile(), DepositFileType.supplement);
                } catch (IOException e) {
                    throw new RuntimeException(e.getMessage(), e);
                }
            }
        });

        DepositSubmission submission =
                composeSubmission(this.getClass().getName() + "-" + testName.getMethodName(),
                        custodialContentWithTypes);


        PackageStream stream = underTest.assemble(submission);

        File tmpOut = DepositTestUtil.tmpFile(this.getClass(), testName, ".zip");

        try (InputStream in = stream.open()) {
            Files.copy(in, tmpOut.toPath(), StandardCopyOption.REPLACE_EXISTING);
        }

        LOG.debug(">>>> Wrote package to '{}'", tmpOut);

        // expect a file for every resource under data/ directory
        // expect a mets xml file at the base directory
        // expect mets xml to have a fileSec with a file for each resource with the correct path

        extractedPackageDir = DepositTestUtil.openArchive(tmpOut);

        LOG.debug(">>>> Extracted package to '{}'", extractedPackageDir);

        metsDoc = DepositTestUtil.getMetsXml(extractedPackageDir);
    }

    /**
     *
     * Insures the locations of the files in the package are as expected, and that the mets.xml is present and correctly
     * links the files.
     *
     * @throws Exception
     */
    @Test
    public void testPackageStructure() throws Exception {
        List<String> custodialResourceFilenames = custodialResources.stream()
                .map(Resource::getFilename).collect(Collectors.toList());

        // expect a file for every resource under data/ directory
        // expect a mets xml file at the base directory
        // expect mets xml to have a fileSec with a file for each resource with the correct path

        // Each custodial resource is represented in the package under the 'data/' directory
        custodialResources.forEach(custodialResource -> {
            assertTrue(extractedPackageDir.toPath().resolve("data/" + custodialResource.getFilename()).toFile().exists());
        });

        // Each custodial resource in the package has a File and Fptr in METS.xml, pointing to the correct location.
        /*
        <fileSec ID="b7a991c6-4d9a-4c93-9646-aeb3a314d0ae">
            <fileGrp ID="b6efacc8-b9b6-418e-8dd2-a42c60c6f08e" USE="CONTENT">
                <file CHECKSUM="03ffb26edcf6efe77c8acfaefa5ceffb" CHECKSUMTYPE="MD5"
                    ID="5f37c90d-d8d8-42d3-92e4-294ccec71976" MIMETYPE="image/tiff" SIZE="6640585">
                    <FLocat ID="91195427-9bea-42d6-8815-c392016b63c0" LOCTYPE="URL"
                        xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="data/Figure1.tif"/>
                </file>
                <file CHECKSUM="9bd7573f8820f44548d6fe2a225fbe7a" CHECKSUMTYPE="MD5"
                    ID="6dd5f7c6-d4d9-4435-9e36-cfb373f225fb" MIMETYPE="text/plain" SIZE="72">
                    <FLocat ID="ca54ce92-6fde-4932-bd9a-fa2a9ecac786" LOCTYPE="URL"
                        xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="data/manifest.txt"/>
                </file>
                <file CHECKSUM="8ac686ffd8a01c888bfed5130d3ac58c" CHECKSUMTYPE="MD5"
                    ID="99d33e71-4ae5-4895-9014-c96de74bcc50" MIMETYPE="application/xml" SIZE="591">
                    <FLocat ID="8fe756b2-a687-4aaf-b6e1-b9e485c9d855" LOCTYPE="URL"
                        xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="data/meta.xml"/>
                </file>
                <file CHECKSUM="2e5675221da66a2a4faa25d7c71dfb09" CHECKSUMTYPE="MD5"
                    ID="ca11b3e9-5689-4f77-8661-558d0f61087e" MIMETYPE="application/x-tika-msoffice"
                    SIZE="68608">
                    <FLocat ID="fc25705a-71b8-4cbb-aa12-da657710e931" LOCTYPE="URL"
                        xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="data/Sample2.doc"/>
                </file>
            </fileGrp>
        </fileSec>
         */

        List<Element> flocats = asList(metsDoc.getElementsByTagNameNS(METS_NS, METS_FLOCAT));
        List<String> flocatHrefs = flocats.stream()
                .map(flocat -> flocat.getAttributeNS(XLINK_NS, XLINK_HREF)).collect(Collectors.toList());

        // each custodial resource has an flocat, and each flocat has a custodial resource
        assertEquals("Expected '" + custodialResources.size() + "' flocat elements in the package metadata",
                custodialResources.size(), flocats.size());
        custodialResources.forEach(custodialResource -> {
            assertTrue(flocatHrefs.contains("data/" + custodialResource.getFilename()));
        });
        flocatHrefs.forEach(flocat -> {
            assertTrue(custodialResourceFilenames.contains(flocat.substring("data/".length())));
        });
    }

    /**
     * Insures that the checksums for the METS file elements are correct.
     *
     * @throws Exception
     */
    @Test
    public void testPackageIntegrity() throws Exception {
        Map<String, PackageStream.Checksum> expectedChecksums = new HashMap<>();

        Map<String, PackageStream.Checksum> actualChecksums = new HashMap<>();

        asList(metsDoc.getElementsByTagNameNS(METS_NS, METS_FILE))
                .forEach(fileElement -> {
                    // expected checksums for each package resource
                    String algo = fileElement.getAttribute(METS_CHECKSUM_TYPE);
                    String checksumValue = fileElement.getAttribute(METS_CHECKSUM);
                    String fileName = ((Element) fileElement.getFirstChild())
                            .getAttributeNS(XLINK_NS, XLINK_HREF).substring("data/".length());
                    PackageStream.Checksum checksum = mock(PackageStream.Checksum.class);
                    PackageStream.Algo packageStreamAlgo = PackageStream.Algo.valueOf(algo);
                    when(checksum.algorithm()).thenReturn(packageStreamAlgo);
                    when(checksum.asHex()).thenReturn(checksumValue);

                    expectedChecksums.put(fileName, checksum);

                    // calculate checksums for each package resource
                    try (InputStream resourceIn = Files.newInputStream(extractedPackageDir.toPath().resolve("data/" + fileName));
                         ObservableInputStream obsIn = new ObservableInputStream(resourceIn)) {
                        ResourceBuilder builder = rbf.newInstance();
                        DigestObserver digestObserver = new DigestObserver(builder, packageStreamAlgo);
                        obsIn.add(digestObserver);
                        IOUtils.copy(obsIn, new NullOutputStream());
                        actualChecksums.put(fileName, builder.build().checksum());
                    } catch (IOException e) {
                        throw new RuntimeException(e.getMessage(), e);
                    }
                });


        assertEquals(expectedChecksums.size(), actualChecksums.size());
        expectedChecksums.forEach((filename, checksum) -> {
            assertTrue(actualChecksums.containsKey(filename));
            assertEquals(checksum.algorithm(), actualChecksums.get(filename).algorithm());
            assertEquals(checksum.asHex(), actualChecksums.get(filename).asHex());
        });
    }

    /**
     * Insures that there is a mimetype present and correct size attribute present on METS file elements
     * @throws Exception
     */
    @Test
    public void testFileMetadata() throws Exception {
        asList(metsDoc.getElementsByTagNameNS(METS_NS, METS_FILE))
                .forEach(fileElement -> {
                    assertNotNull(fileElement.getAttribute(METS_MIMETYPE));
                    String fileName = ((Element) fileElement.getFirstChild())
                            .getAttributeNS(XLINK_NS, XLINK_HREF).substring("data/".length());
                    try {
                        assertEquals((Long) custodialResourcesMap.get(fileName).contentLength(),
                                Long.valueOf(fileElement.getAttribute(METS_SIZE)));
                    } catch (IOException e) {
                        throw new RuntimeException(e.getMessage(), e);
                    }
                });
    }

}
